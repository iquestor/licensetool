
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "base32.h"
#include "hmac_sha2.h"

#define DEBUG_LOG 0

#if (defined DEBUG_LOG && DEBUG_LOG)
#define LOG printf
#else
#define LOG(...) /* */
#endif

/*
 * A license is generated by concatenating the company name, limit number and the
 * hexidecmial representation of the first 4 bytes of the HMAC_SHA2 of the
 * concatenation of the company name and limit number + master key and encoding the encrypted
 * copy using Base32. Concatenated strings MUST be seperated by a colon. Encryption is 
 * performed by XORing the "master key" across the contents of the concatenated license
 * wrapping the "master key" index if necessary.
 *
 * Example:
 * Concatented (plain text) license: Foo Bar, Inc.:50:3d654b27
 * Base32 encoded (encrypted) license: GYXUWBBVKEAEQUAJJJDVSCSHKRFHGQASIICBAVSH
 *
 * Psuedo Code:
 * char * company = "Foo Bar, Inc.";
 * char * limit = "50";
 * char * master_key = "p@$$w0rd";
 * char * hmac = hmac_sha2(company + ":" + limit, master_key);
 * char * encrypted = encrypt(company + ":" + limit + ":" + hex(hmac[0...4]));
 * char * license = base32(encrypted);
 */

char * generate_license(const unsigned limit, const char * company_name, const char * master_key)
{
	assert(limit > 0);
	assert(company_name);
	assert(master_key);

	char * license = 0;
	
	char buf[512] = { 0 };
	
	strcpy(buf, company_name);
	strcat(buf, ":");
	
	char limit_buf[8] = { 0 };
	
	sprintf(limit_buf, "%d", limit);
	
	strcat(buf, limit_buf);
	
	unsigned char mac[128] = { 0 };
	
	hmac_sha512(
		(const unsigned char *)master_key, strlen(master_key),
		(unsigned char *)buf, strlen(buf), mac, sizeof(mac)
	);
	
	strcat(buf, ":");
	
	char hmac_hex[64] = { 0 };
	
	for (unsigned i = 0; i < 4; i++)
	{
		sprintf(&hmac_hex[i * 2], "%02x", mac[i]);
	}

	strcat(buf, hmac_hex);
	
	LOG("buf = %s\n", buf);

	/**
	 * XOR encrypt.
	*/
	unsigned mkey_index = 0;
	
	unsigned buf_len = strlen(buf);

	for (unsigned i = 0; i < buf_len; i++)
	{
		buf[i] ^= master_key[mkey_index++];
		
		if (mkey_index == strlen(master_key))
		{
			mkey_index = 0;
		}
	}

	license = base32_encode(buf, buf_len); // caller must free
	
	return license;
}

int validate_license(const char * license, unsigned * limit, const char * master_key)
{
	int ret = -1;
	
	unsigned int decoded_len = strlen(license);
	
	char * decoded = (char *)base32_decode(license, &decoded_len);

	/**
	 * XOR Decrypt.
	 */
	unsigned mkey_index = 0;
		
	for (unsigned i = 0; i < decoded_len; i++)
	{
		decoded[i] ^= master_key[mkey_index++];
		
		if (mkey_index == strlen(master_key))
		{
			mkey_index = 0;
		}
	}

	LOG("decoded = %s\n", decoded);
	
	// get company name
	char * company_name = strtok(decoded, ":");
	
	if (!company_name)
	{
		return -1;
	}

	LOG("company_name = %s\n", company_name);
	
	// get limit
	char * limit_str = strtok(0, ":");

	if (!limit_str)
	{
		return -1;
	}
	
	LOG("limit_str = %s\n", limit_str);
	
	// get hex for testing
	//char * hex_str = strtok(0, ":");
	//LOG("hex_str = %s\n", hex_str);
	
	char buf[512] = { 0 };
	
	strcpy(buf, company_name);
	strcat(buf, ":");
	strcat(buf, limit_str);

	*limit = atoi(limit_str);

	unsigned char mac[128] = { 0 };
	
	hmac_sha512(
		(const unsigned char *)master_key, strlen(master_key),
		(unsigned char *)buf, strlen(buf), mac, sizeof(mac)
	);
	
	strcat(buf, ":");

	char hmac_hex[64] = { 0 };

	for (unsigned i = 0; i < 4; i++)
	{
		sprintf(&hmac_hex[i * 2], "%02x", mac[i]);
	}

	strcat(buf, hmac_hex);

	LOG("buf = %s\n", buf);
	
	free(decoded);
	
	unsigned buf_len = strlen(buf);

	/**
	 * XOR encrypt.
	*/
	mkey_index = 0;

	for (unsigned i = 0; i < buf_len; i++)
	{
		buf[i] ^= master_key[mkey_index++];
		
		if (mkey_index == strlen(master_key))
		{
			mkey_index = 0;
		}
	}
	
	char * encoded = base32_encode(buf, buf_len); 
	
	LOG("a = %s, b = %s\n", license, encoded);
	
	ret = strcmp(license, encoded);
	
	free(encoded);
	
	return ret;
}

#if 0
int main()
{
	char * license = generate_license(50, "Foo Bar, Inc.", "p@$$w0rd");
	
	printf("Generated license = %s\n", license);
	
	unsigned limit = 0;
	
	if (validate_license(license, &limit, "p@$$w0rd") == 0)
	{
		printf("License is valid, limit  %d.\n", limit);
	}
	else
	{
		printf("License is invalid.\n");
	}
	
	free(license);
		
	return 0;
}

#endif